<!DOCTYPE html>
<html>
<head>
    <title>Tattoo Services</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div style="position: fixed; top: 5%; left: 0; width: 100%; display: flex; align-items: center; justify-content: center; font-size: 12vw; font-weight: bold; z-index: -1; text-align: center; color: #333; line-height: 0.8;">
        TATTOO SERVICES
    </div>
    
    <div style="position: fixed; bottom: 5%; left: 0; width: 100%; display: flex; align-items: center; justify-content: center; font-size: 8vw; font-weight: bold; z-index: -1; text-align: center; color: #333; line-height: 0.8;">
        CHEAP!IM LEARNING
    </div>
    
    <canvas id="canvas" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: crosshair; z-index: 1;"></canvas>
    <canvas id="particles" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3;"></canvas>
    <canvas id="cable" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2;"></canvas>
    <canvas id="machine" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 4;"></canvas>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const particleCanvas = document.getElementById('particles');
        const particleCtx = particleCanvas.getContext('2d');
        const cableCanvas = document.getElementById('cable');
        const cableCtx = cableCanvas.getContext('2d');
        const machineCanvas = document.getElementById('machine');
        const machineCtx = machineCanvas.getContext('2d');
        
        let img = new Image();
        let machineImg = new Image();
        let imageData;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let distanceDrawn = 0;
        const brushSpacing = 0.75;
        const brushSize = 3;
        
        // Fluid simulation parameters - heavily optimized for Safari
        let particles = [];
        const maxParticles = 400; // Further reduced from 800
        const viscosity = 0.92;
        const gravity = 0.4;
        const cohesion = 0.6;
        const separation = 15;
        const surfaceTension = 0.1;
        
        // Spatial grid for optimization
        const gridSize = 30; // Larger grid for fewer calculations
        let grid = {};
        let frameCount = 0;
        
        // Cable physics - simplified for Safari
        const cableSegments = 20; // Reduced from 40
        const segmentLength = 25; // Reduced from 30
        let cablePoints = [];
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let targetMouseX = mouseX;
        let targetMouseY = mouseY;
        
        // Cable optimization variables
        let cableUpdateCounter = 0;
        let lastCableUpdate = 0;
        const cableUpdateInterval = 16; // Update every 16ms (60fps max)
        
        // Initialize cable points with simpler physics
        for (let i = 0; i < cableSegments; i++) {
            cablePoints.push({
                x: window.innerWidth - 50,
                y: 50 + i * segmentLength,
                vx: 0,
                vy: 0,
                oldX: window.innerWidth - 50,
                oldY: 50 + i * segmentLength,
                pinned: i === 0 // Only first point is pinned
            });
        }
        
        // Set canvas sizes to window size
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;
        cableCanvas.width = window.innerWidth;
        cableCanvas.height = window.innerHeight;
        machineCanvas.width = window.innerWidth;
        machineCanvas.height = window.innerHeight;
        
        // Load tattoo machine image
        machineImg.onload = function() {
            console.log('Tattoo machine image loaded successfully');
        };
        
        machineImg.onerror = function() {
            console.log('Could not load maszynka.png');
        };
        
        machineImg.src = 'maszynka.png';
        
        // Load main image without frame requirement
        img.onload = function() {
            const maxWidth = window.innerWidth * 0.6;
            const maxHeight = window.innerHeight * 0.6;
            
            let scale = Math.min(maxWidth / img.width, maxHeight / img.height);
            
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        };
        
        img.onerror = function() {
            const maxWidth = window.innerWidth * 0.6;
            const maxHeight = window.innerHeight * 0.6;
            
            canvas.width = Math.min(500, maxWidth);
            canvas.height = Math.min(500, maxHeight);
            
            ctx.fillStyle = '#f8f8f8';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Image not found - Draw anywhere!', canvas.width/2, canvas.height/2);
            
            // Create fake image data for drawing anywhere
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i + 3] = 255; // Make all pixels drawable
            }
        };
        
        img.src = '1.png';
        
        // Check if pixel is drawable
        function canDrawAt(x, y) {
            if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return false;
            if (!imageData) return true;
            const index = (y * canvas.width + x) * 4;
            return imageData.data[index + 3] > 50;
        }
        
        // Particle class - further optimized for Safari
        class FluidParticle {
            constructor(x, y) {
                const rect = canvas.getBoundingClientRect();
                this.x = rect.left + x;
                this.y = rect.top + y;
                this.vx = (Math.random() - 0.5) * 2; // Reduced velocity
                this.vy = Math.random() * -1.5 - 0.5;
                this.life = 30; // Further reduced lifespan
                this.maxLife = this.life;
                this.size = Math.random() * 2 + 1;
                this.density = 1;
                this.pressure = 0;
                this.viscosityForce = { x: 0, y: 0 };
                this.cohesionForce = { x: 0, y: 0 };
                this.separationForce = { x: 0, y: 0 };
            }
            
            update() {
                this.life--;
                
                // Apply gravity
                this.vy += gravity * 0.8; // Reduced gravity effect
                
                // Apply fluid forces (only every 4th frame for performance)
                if (frameCount % 4 === 0) {
                    this.vx += (this.viscosityForce.x + this.cohesionForce.x + this.separationForce.x) * 0.5;
                    this.vy += (this.viscosityForce.y + this.cohesionForce.y + this.separationForce.y) * 0.5;
                }
                
                // Apply viscosity (damping)
                this.vx *= viscosity;
                this.vy *= viscosity;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Simplified boundary collision
                if (this.x < this.size) {
                    this.x = this.size;
                    this.vx *= -0.2;
                }
                if (this.x > window.innerWidth - this.size) {
                    this.x = window.innerWidth - this.size;
                    this.vx *= -0.2;
                }
                if (this.y > window.innerHeight - this.size) {
                    this.y = window.innerHeight - this.size;
                    this.vy *= -0.1;
                    this.vx *= 0.7;
                }
                
                // Reset forces
                this.viscosityForce = { x: 0, y: 0 };
                this.cohesionForce = { x: 0, y: 0 };
                this.separationForce = { x: 0, y: 0 };
            }
            
            draw() {
                const alpha = Math.min(0.7, (this.life / this.maxLife) * 0.9);
                const intensity = Math.min(180, 80 + (1 - alpha) * 60);
                
                // Simplified drawing - no gradient for better performance
                particleCtx.fillStyle = `rgba(${intensity}, 0, 0, ${alpha})`;
                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                particleCtx.fill();
            }
        }
        
        // Simplified spatial grid functions
        function getGridKey(x, y) {
            return `${Math.floor(x / gridSize)},${Math.floor(y / gridSize)}`;
        }
        
        function updateGrid() {
            grid = {};
            particles.forEach((particle, index) => {
                const key = getGridKey(particle.x, particle.y);
                if (!grid[key]) grid[key] = [];
                grid[key].push(index);
            });
        }
        
        function getNearbyParticles(particle) {
            const nearby = [];
            const gx = Math.floor(particle.x / gridSize);
            const gy = Math.floor(particle.y / gridSize);
            
            // Only check immediate neighbors for performance
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const key = `${gx + dx},${gy + dy}`;
                    if (grid[key]) {
                        grid[key].forEach(index => {
                            const other = particles[index];
                            if (other !== particle) {
                                const dist = Math.sqrt(
                                    (particle.x - other.x) ** 2 + 
                                    (particle.y - other.y) ** 2
                                );
                                if (dist < separation) {
                                    nearby.push({ particle: other, distance: dist });
                                }
                            }
                        });
                    }
                }
            }
            return nearby.slice(0, 3); // Limit to 3 nearest neighbors
        }
        
        // Heavily optimized fluid simulation
        function calculateFluidForces() {
            // Only calculate forces every 6 frames for performance
            if (frameCount % 6 !== 0) return;
            
            updateGrid();
            
            // Process only a small subset of particles each frame
            const batchSize = Math.min(20, particles.length);
            const startIndex = Math.floor((frameCount / 6) % Math.max(1, Math.ceil(particles.length / batchSize))) * batchSize;
            
            for (let i = 0; i < batchSize && startIndex + i < particles.length; i++) {
                const particle = particles[startIndex + i];
                const nearby = getNearbyParticles(particle);
                
                // Limit interactions to maximum 2 particles
                const maxInteractions = Math.min(2, nearby.length);
                
                for (let j = 0; j < maxInteractions; j++) {
                    const { particle: other, distance } = nearby[j];
                    if (distance > 0) {
                        const dx = (particle.x - other.x) / distance;
                        const dy = (particle.y - other.y) / distance;
                        
                        // Simplified forces with reduced strength
                        if (distance < separation * 0.6) {
                            const force = (separation * 0.6 - distance) * 0.02;
                            particle.separationForce.x += dx * force;
                            particle.separationForce.y += dy * force;
                        }
                        
                        if (distance < separation && distance > separation * 0.4) {
                            const force = cohesion * 0.005;
                            particle.cohesionForce.x -= dx * force;
                            particle.cohesionForce.y -= dy * force;
                        }
                    }
                }
            }
        }
        
        // Simplified cable physics for Safari
        function updateCable() {
            const now = Date.now();
            if (now - lastCableUpdate < cableUpdateInterval) return;
            lastCableUpdate = now;
            
            // Smooth mouse following with interpolation
            targetMouseX += (mouseX - targetMouseX) * 0.15;
            targetMouseY += (mouseY - targetMouseY) * 0.15;
            
            // Update first point to follow smoothed mouse position
            cablePoints[0].x = targetMouseX + 30;
            cablePoints[0].y = targetMouseY;
            
            // Simplified Verlet integration
            for (let i = 1; i < cablePoints.length; i++) {
                const point = cablePoints[i];
                const tempX = point.x;
                const tempY = point.y;
                
                // Reduced physics calculations
                const dampingFactor = 0.96; // Increased damping for stability
                point.x += (point.x - point.oldX) * dampingFactor;
                point.y += (point.y - point.oldY) * dampingFactor + 0.3; // Reduced gravity
                
                point.oldX = tempX;
                point.oldY = tempY;
            }
            
            // Simplified constraint solving - only 2 iterations
            for (let j = 0; j < 2; j++) {
                for (let i = 0; i < cablePoints.length - 1; i++) {
                    const p1 = cablePoints[i];
                    const p2 = cablePoints[i + 1];
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0.1) { // Avoid division by very small numbers
                        const diff = segmentLength - dist;
                        const percent = (diff / dist) * 0.5; // Reduced correction strength
                        const offsetX = dx * percent;
                        const offsetY = dy * percent;
                        
                        if (i !== 0) { // Don't move the first point
                            p1.x -= offsetX * 0.5;
                            p1.y -= offsetY * 0.5;
                        }
                        p2.x += offsetX * 0.5;
                        p2.y += offsetY * 0.5;
                    }
                }
            }
        }
        
        // Optimized cable drawing
        function drawCable() {
            cableCtx.clearRect(0, 0, cableCanvas.width, cableCanvas.height);
            
            if (cablePoints.length < 2) return;
            
            // Draw cable shadow (simplified)
            cableCtx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            cableCtx.lineWidth = 10;
            cableCtx.lineCap = 'round';
            cableCtx.lineJoin = 'round';
            cableCtx.beginPath();
            cableCtx.moveTo(cablePoints[0].x + 1, cablePoints[0].y + 1);
            for (let i = 1; i < cablePoints.length; i++) {
                cableCtx.lineTo(cablePoints[i].x + 1, cablePoints[i].y + 1);
            }
            cableCtx.stroke();
            
            // Draw main cable
            cableCtx.strokeStyle = '#222';
            cableCtx.lineWidth = 6;
            cableCtx.beginPath();
            cableCtx.moveTo(cablePoints[0].x, cablePoints[0].y);
            for (let i = 1; i < cablePoints.length; i++) {
                cableCtx.lineTo(cablePoints[i].x, cablePoints[i].y);
            }
            cableCtx.stroke();
            
            // Simplified highlight
            cableCtx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            cableCtx.lineWidth = 1;
            cableCtx.beginPath();
            cableCtx.moveTo(cablePoints[0].x - 1, cablePoints[0].y - 1);
            for (let i = 1; i < cablePoints.length; i++) {
                cableCtx.lineTo(cablePoints[i].x - 1, cablePoints[i].y - 1);
            }
            cableCtx.stroke();
        }
        
        // Draw tattoo machine (cached for performance)
        let machineDrawCache = null;
        let lastMachineX = -1;
        let lastMachineY = -1;
        
        function drawMachine() {
            // Only redraw if machine moved significantly
            if (Math.abs(mouseX - lastMachineX) < 2 && Math.abs(mouseY - lastMachineY) < 2) {
                return;
            }
            
            machineCtx.clearRect(0, 0, machineCanvas.width, machineCanvas.height);
            
            if (machineImg.complete && machineImg.naturalWidth > 0) {
                const machineSize = 80; // Slightly smaller for performance
                const machineX = mouseX - machineSize / 2;
                const machineY = mouseY - machineSize / 2;
                
                // Simplified shadow
                machineCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                machineCtx.shadowBlur = 5;
                machineCtx.shadowOffsetX = 2;
                machineCtx.shadowOffsetY = 2;
                
                machineCtx.drawImage(machineImg, machineX, machineY, machineSize, machineSize);
                
                // Reset shadow
                machineCtx.shadowColor = 'transparent';
                machineCtx.shadowBlur = 0;
                machineCtx.shadowOffsetX = 0;
                machineCtx.shadowOffsetY = 0;
            } else {
                // Simplified fallback
                machineCtx.fillStyle = '#333';
                machineCtx.fillRect(mouseX - 15, mouseY - 30, 30, 45);
                machineCtx.fillStyle = '#666';
                machineCtx.fillRect(mouseX - 12, mouseY - 25, 24, 15);
                machineCtx.fillStyle = '#999';
                machineCtx.fillRect(mouseX - 1, mouseY + 10, 2, 10);
            }
            
            lastMachineX = mouseX;
            lastMachineY = mouseY;
        }
        
        // Draw with brush
        function drawBrush(x, y) {
            if (!canDrawAt(Math.floor(x), Math.floor(y))) return;
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x, y, brushSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Spawn fewer fluid particles
            spawnFluidParticles(x, y);
        }
        
        // Optimized particle spawning
        function spawnFluidParticles(x, y) {
            const spawnCount = Math.min(1, maxParticles - particles.length); // Only 1 particle per draw
            
            for (let i = 0; i < spawnCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * brushSize * 0.8;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                
                particles.push(new FluidParticle(px, py));
            }
            
            // More aggressive particle cleanup
            if (particles.length > maxParticles * 0.7) {
                particles.splice(0, particles.length - Math.floor(maxParticles * 0.7));
            }
        }
        
        // Heavily optimized animation loop for Safari
        function animate() {
            frameCount++;
            
            // Clear particles canvas less frequently
            if (frameCount % 3 === 0) {
                particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            }
            
            // Update cable less frequently
            if (frameCount % 2 === 0) {
                updateCable();
            }
            
            // Draw cable even less frequently
            if (frameCount % 3 === 0) {
                drawCable();
            }
            
            // Draw machine only when needed
            if (frameCount % 2 === 0) {
                drawMachine();
            }
            
            // Calculate fluid forces much less frequently
            if (particles.length > 1 && frameCount % 8 === 0) {
                calculateFluidForces();
            }
            
            // Update and draw particles in batches
            const particleUpdateBatch = Math.min(20, particles.length); // Process max 20 particles per frame
            const startIndex = frameCount % Math.max(1, Math.ceil(particles.length / particleUpdateBatch)) * particleUpdateBatch;
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Update particles in batches
                if (i >= startIndex && i < startIndex + particleUpdateBatch) {
                    particle.update();
                }
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                } else if (frameCount % 2 === 0) { // Draw less frequently
                    particle.draw();
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Throttled mouse tracking for better performance
        let mouseUpdateThrottle = 0;
        document.addEventListener('mousemove', (e) => {
            if (Date.now() - mouseUpdateThrottle > 16) { // 60fps max
                mouseX = e.clientX;
                mouseY = e.clientY;
                mouseUpdateThrottle = Date.now();
            }
        });
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            distanceDrawn = 0;
            drawBrush(lastX, lastY);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            const dx = currentX - lastX;
            const dy = currentY - lastY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const steps = Math.max(1, Math.floor(distance / (brushSize * 2 * brushSpacing)));
                
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = lastX + dx * t;
                    const y = lastY + dy * t;
                    drawBrush(x, y);
                }
                
                lastX = currentX;
                lastY = currentY;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastX = touch.clientX - rect.left;
            lastY = touch.clientY - rect.top;
            isDrawing = true;
            drawBrush(lastX, lastY);
            
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const currentX = touch.clientX - rect.left;
            const currentY = touch.clientY - rect.top;
            
            mouseX = touch.clientX;
            mouseY = touch.clientY;
            
            const dx = currentX - lastX;
            const dy = currentY - lastY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const steps = Math.max(1, Math.floor(distance / (brushSize * 2 * brushSpacing)));
                
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = lastX + dx * t;
                    const y = lastY + dy * t;
                    drawBrush(x, y);
                }
                
                lastX = currentX;
                lastY = currentY;
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            cableCanvas.width = window.innerWidth;
            cableCanvas.height = window.innerHeight;
            machineCanvas.width = window.innerWidth;
            machineCanvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
